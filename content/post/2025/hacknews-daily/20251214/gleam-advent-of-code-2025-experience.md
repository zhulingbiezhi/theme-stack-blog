---
title: "用 Gleam 挑战 Advent of Code 2025：一次函数式编程的实战体验"
date: 2025-12-14
tags:
  - "Gleam"
  - "函数式编程"
  - "Advent of Code"
  - "编程语言"
  - "实战经验"
categories:
  - "编程语言探索"
draft: false
description: "本文深入解析了作者使用新兴函数式语言 Gleam 完成 Advent of Code 2025 挑战的实战经历。文章不仅分享了 Gleam 在解决算法问题时的优雅语法和强大能力，还探讨了其类型系统、包管理器、工具链的成熟度，为对函数式编程或 Gleam 感兴趣的开发者提供了宝贵的实践参考和深度洞察。"
slug: "gleam-advent-of-code-2025-experience"
---

## 文章摘要

本文详细记录了作者使用 Gleam 编程语言完成 Advent of Code 2025 挑战的完整经历。Advent of Code 是一个年度编程挑战活动，以其巧妙的算法和数据结构问题著称，常被开发者用来学习和评估新语言。作者通过这一系列实战问题，深入探索了 Gleam 这门新兴的、运行在 Erlang 虚拟机上的函数式语言。文章的核心在于分享 Gleam 在实际编码中的体验，包括其简洁的语法、强大的模式匹配、友好的错误信息以及尚在成长中的生态系统。对于任何考虑学习函数式编程或寻找 Rust 与 Elixir 之外新选择的开发者而言，这篇文章提供了极具价值的、来自一线的实践洞察。

## 背景与问题

在当今多范式编程语言百花齐放的时代，开发者们不断寻找着在生产力、安全性和性能之间取得最佳平衡的工具。函数式编程因其强调不可变性、纯函数和声明式风格，在构建高并发、高可靠性的系统方面展现出独特优势。然而，传统函数式语言如 Haskell 的高学习曲线，或 Scala 的复杂性，常常让初学者望而却步。在此背景下，一些新兴的、设计更为友好的函数式语言开始受到关注，Gleam 便是其中之一。

Gleam 是一门静态类型的函数式编程语言，其语法简洁明了，编译为 Erlang 字节码，可直接运行在强大的 BEAM 虚拟机（Erlang 运行时）上。这意味着它天然继承了 Erlang/OTP 平台在构建分布式、高容错、软实时系统方面的超强能力。Gleam 的设计目标之一是提供出色的类型安全性和编译器错误信息，同时保持较低的学习门槛，吸引来自不同背景的开发者。

那么，如何有效地评估一门新语言的实用性和开发体验呢？Advent of Code（AoC）提供了一个绝佳的“试金石”。AoC 是一系列从 12 月 1 日到 25 日每天发布的编程谜题，问题设计巧妙，覆盖字符串处理、图论、动态规划、解析等多种计算机科学主题。它不强调竞争速度，而是鼓励探索、学习和使用不同的工具解决问题。因此，越来越多的开发者选择用 AoC 来“试驾”一门新语言，在解决具体问题的过程中，切身感受其语法、标准库、工具链和开发流程。

本文作者面临的核心问题正是：**对于一个熟悉其他编程范式（如面向对象或命令式）的开发者，Gleam 是否是一门易于上手且高效解决问题的函数式语言？它在处理典型算法挑战时的表现如何？其生态系统是否足够支撑日常开发？** 通过将 Gleam 应用于 AoC 2025 的实战，作者为我们揭晓了这些问题的答案。

## 核心内容解析

### 核心观点提取

**1. 语法简洁优雅，学习曲线平缓**
Gleam 的语法设计明显受到了 ML 家族语言（如 OCaml, F#）和 Rust 的影响，去除了许多历史包袱。函数定义清晰，管道运算符（`|>`）让数据流转换变得直观，模式匹配是语言的一等公民。对于有 JavaScript、Python 或 Rust 经验的开发者，上手速度会很快。

**2. 类型系统强大且“安静”**
Gleam 拥有一个健全的静态类型系统，能在编译期捕获大量错误。但与其他语言不同的是，Gleam 支持**类型推断**，你很少需要显式地写出类型注解，编译器能聪明地推断出大部分类型。这使得代码在保持安全性的同时，看起来非常简洁，减少了视觉噪音。

**3. 错误信息极其友好**
这是 Gleam 备受赞誉的一点。当代码出现类型错误时，编译器不会抛出晦涩难懂的信息，而是会清晰地指出问题所在，甚至给出修改建议。这对于学习过程和日常调试是巨大的助力，显著降低了心智负担。

**4. 与 BEAM 生态的无缝集成是双刃剑**
Gleam 可以轻松调用 Erlang 和 Elixir 的库，这极大地扩展了其能力范围，尤其是在需要成熟 OTP 抽象（如 GenServer、Supervisor）时。然而，这种互操作有时需要一些“胶水代码”，并且 Erlang 库的文档风格可能与 Gleam 不同，需要适应。

**5. 工具链高效但生态系统仍在成长**
Gleam 的构建工具 `gleam` 非常高效，集成了项目管理、编译、依赖管理、代码格式化、测试运行等功能。包管理器能够快速处理依赖。不过，与主流语言相比，Gleam 的第三方库（特别是纯 Gleam 库）数量还较少，对于某些特定任务，你可能需要自己动手实现或依赖 Erlang 库。

**6. 模式匹配和不可变性是问题解决的利器**
在解决 AoC 问题时，模式匹配在处理复杂数据结构（如嵌套的 `Result` 或 `Option` 类型）和解析输入数据时显得游刃有余。语言的不可变性默认保证了函数没有副作用，这使得推理程序行为、编写测试和并发编程都更加简单。

**7. 对字符串和列表的处理符合直觉但需注意性能**
Gleam 的字符串是 UTF-8 编码的二进制，列表是单向链表。其标准库提供的函数式操作（如 `map`, `filter`, `fold`）用起来很顺手。但在处理大规模数据或需要频繁随机访问时，开发者需要意识到链表和 Erlang 二进制数据的性能特征，有时需要选择更合适的数据结构（如来自 Erlang 的 `:array` 模块）。

### 技术深度分析

Gleam 的设计哲学是在不牺牲表达力和安全性的前提下，追求极致的开发者体验。我们通过几个技术细节来深入理解这一点。

**类型系统与类型推断**：Gleam 的类型系统基于 Hindley-Milner 类型系统，这是 ML 语言家族的基石。它支持参数多态（泛型），例如 `List(a)` 表示一个元素类型为 `a` 的列表。编译器在编译时进行全局类型推断，这意味着你可以写出如下代码而无需任何类型注解：
```gleam
// 编译器能推断出 parse_and_double 的类型是 String -> Result(Int, String)
pub fn parse_and_double(str: String) {
  case int.parse(str) {
    Ok(num) -> Ok(num * 2)
    Error(_) -> Error("Not a number")
  }
}
```
这种“类型安全但无类型噪音”的特性，是 Gleam 吸引人的关键。它让代码读起来像动态类型语言一样轻快，却拥有静态类型语言的所有安全保障。

**错误处理范式**：Gleam 没有异常机制，而是使用 `Result(O, E)` 类型来处理可能失败的操作。这强制开发者显式地处理所有错误路径，避免了错误被意外忽略。结合强大的模式匹配，错误处理代码可以写得既安全又清晰：
```gleam
pub fn process_file(path: String) -> Result(String, String) {
  // file.read 返回 Result(String, FileError)
  try content = file.read(path)
  try parsed = parse_content(content) // 假设 parse_content 也返回 Result
  Ok(do_something(parsed))
}
```
这里的 `try` 关键字是语法糖，如果表达式是 `Error(e)`，它会提前从函数返回 `Error(e)`；如果是 `Ok(value)`，则会将值绑定到变量（如 `content`）。这大大简化了错误传播的代码。

**与 BEAM 的互操作**：Gleam 通过 `external` 函数声明来调用 Erlang/Elixir 代码。这是其生态扩展的生命线。
```gleam
// 调用 Erlang 的 `lists:seq` 函数
external fn create_sequence(Int, Int) -> List(Int) =
  "lists" "seq"

pub fn main() {
  create_sequence(1, 5) // => [1, 2, 3, 4, 5]
}
```
这种设计使得 Gleam 项目可以立即利用 BEAM 生态系统中数以千计经过实战检验的库，特别是在网络、数据库、分布式计算等领域。然而，开发者需要理解 Erlang 的术语（Term）如何映射到 Gleam 的类型，这需要一定的学习成本。

**性能考量**：运行在 BEAM 上意味着 Gleam 继承了其“软实时”和“高并发”的特性。对于大量并行、I/O 密集型的任务（如 Web 服务器），它表现出色。但对于纯 CPU 密集型的数值计算，其性能可能不如 C、Rust 或 Go。在 AoC 的上下文中，大部分问题规模可控，Gleam 的性能完全足够，甚至得益于 BEAM 调度器，在并发求解时可能有意外之喜。

### 实践应用场景

Gleam 的特性使其在多个场景下具有应用潜力：

1.  **后端 Web 服务开发**：结合 Phoenix (Elixir) 生态或直接使用 Gleam 的 Web 框架（如 `mist`），可以构建类型安全、高并发、易于维护的 API 服务器。其不可变性和纯函数特性使得业务逻辑更易于测试和推理。
2.  **CLI 工具与脚本**：Gleam 编译为单个可执行文件，启动速度快。其强大的模式匹配和管道操作符非常适合处理文本和数据转换，可以作为 Bash/Python 脚本的类型安全替代品，用于构建复杂的构建脚本或 DevOps 工具。
3.  **数据处理与管道**：对于需要多个步骤的数据清洗、转换和验证任务，Gleam 的管道运算符 (`|>`) 和函数式组合能力能让代码清晰如数据流图。类型安全保证了数据处理逻辑的正确性。
4.  **教育与学习函数式编程**：由于其友好的错误信息、简洁的语法和实用的类型系统，Gleam 是初学者接触函数式编程核心概念（如不可变性、高阶函数、代数数据类型）的优秀入门语言，避免了 Haskell 的复杂性和学术气息。
5.  **嵌入式领域（Nerves 项目）**：得益于 BEAM 平台，Gleam 理论上可以用于 Nerves 框架，开发嵌入式系统软件，享受函数式编程在状态管理方面的优势。

对于正在考虑新项目技术栈的团队，如果项目需求与高并发、高可靠性、易于维护强相关，并且团队对探索函数式范式持开放态度，那么 Gleam 是一个值得认真评估的选项。

## 深度分析与思考

### 文章价值与意义

这篇实战记录的价值远不止于一份 Gleam 的“体验报告”。首先，它为技术社区提供了一个**基于真实、连贯任务**的语言评估样本。与学习教程中的孤立例子不同，AoC 问题序列模拟了小型但完整的项目开发过程，暴露了语言在项目组织、依赖管理、测试、问题分解等多方面的能力。其次，文章客观地指出了 Gleam 的优缺点，特别是其与成熟 BEAM 生态的集成现状，这对潜在采用者至关重要，帮助他们做出基于信息的决策，而非仅仅基于宣传。最后，文章本身也是 Gleam 社区宝贵的反馈和宣传材料，有助于推动语言的改进和生态的发展。

### 对读者的实际应用价值

对于读者而言，本文的实践价值体现在三个层面：
1.  **技能迁移指南**：如果你来自 JavaScript、Python、Ruby 等动态语言背景，文章展示了如何用函数式的思维（映射、归约、模式匹配）解决熟悉的问题。如果你来自 Java、C# 等静态类型 OOP 语言，文章展示了如何用更少的代码和更清晰的抽象达到同样的类型安全。
2.  **技术选型参考**：如果你正在为一个新服务或工具评估技术栈，文章提供了 Gleam 在开发体验、生产力、性能特征和生态成熟度方面的第一手信息，可以作为选型讨论的实证材料。
3.  **学习路径图**：文章通过解决具体问题，无形中勾勒出一条学习 Gleam 的路径：从基本语法和类型开始，到使用标准库和模式匹配，再到与外部 Erlang 代码交互和项目管理。读者可以跟随这个路径，使用 AoC 或其他练习来巩固学习。

### 可能的实践场景

想要亲身体验 Gleam 的读者，可以尝试以下实践：
- **从 AoC 开始**：选择任何一年的 Advent of Code（题目独立），尝试用 Gleam 解决前几天的题目。这能让你快速感受语言的核心特性。
- **重构小脚本**：找一个你用 Python 或 Bash 写的、约 50-100 行的小型数据处理或文件操作脚本，尝试用 Gleam 重写。对比两者在可读性、错误处理和可维护性上的差异。
- **探索 Web 开发**：按照 `mist` 或 `wisp` 框架的教程，搭建一个简单的 REST API 服务，体验 Gleam 在 Web 上下文下的开发模式。
- **参与社区**：Gleam 社区活跃且友好。在遇到问题时，可以查阅官方指南，或在 Discord、论坛中提问。甚至可以为 Gleam 标准库或流行的第三方库贡献代码或文档，这是深入理解语言的绝佳方式。

### 个人观点与思考

作者对 Gleam 的体验总体是积极的，这印证了其设计目标的成功。Gleam 似乎找到了一个独特的定位：它比 Elixir 更强调静态类型安全，比 Haskell 更易于上手，比 Rust 拥有更成熟的并发运行时（BEAM）。它有可能吸引那些欣赏 Elixir/Erlang 能力但渴望更强类型保证的开发者，以及那些喜欢 Rust 的类型系统但希望有更高开发效率和不同并发模型的开发者。

然而，挑战依然存在。**生态系统的广度**是新兴语言面临的最大障碍。虽然可以调用 Erlang 库，但“原生 Gleam 体验”的库覆盖范围仍需时间积累。**人才市场**上熟悉 Gleam 的开发者较少，这可能影响企业的采用决策。此外，虽然 BEAM 是优势，但也将 Gleam 绑定在特定的虚拟机模型上，对于需要与特定系统库深度集成或追求极致本地性能的场景，这可能成为限制。

展望未来，如果 Gleam 社区能持续增长，围绕 Web 开发、数据序列化、常用客户端（数据库、消息队列）驱动等关键领域形成稳定的高质量库，那么它完全有潜力成为构建可靠后端系统的重要选择之一。它代表了一种趋势：开发者越来越青睐那些能提供强大安全保障而不显著牺牲开发效率的语言。

## 技术栈/工具清单

- **核心语言**：Gleam (版本信息依文章发布时间而定，通常为最新稳定版)
- **运行时平台**：Erlang/OTP 或 Elixir 的 BEAM 虚拟机
- **核心工具**：
    - `gleam`：官方命令行工具，涵盖项目创建、编译、依赖管理、测试、格式化等全生命周期功能。
    - `rebar3` 或 `mix`：可通过 Gleam 工具链集成，用于管理更复杂的 Erlang/Elixir 依赖。
- **开发环境**：
    - **编辑器/IDE**：强大的 Gleam 语言服务器协议支持，可在 VS Code、Vim/Neovim、Emacs、IntelliJ IDEA 等编辑器中获得语法高亮、自动补全、类型提示、跳转定义等支持。
    - **调试**：可借助 Erlang 的观察和调试工具，如 `observer`、`recon`。
- **包管理**：内置的包管理器，从 [Hex.pm](https://hex.pm)（BEAM 生态的包仓库）获取依赖。
- **测试框架**：内置测试运行器，支持简单的单元测试。
- **格式化工具**：内置代码格式化工具 `gleam format`，确保代码风格统一。

## 相关资源与延伸阅读

- **原文链接**：[I tried Gleam for Advent of Code](https://blog.tymscar.com/posts/gleamaoc2025/) - 本文分析的原始文章。
- **Gleam 官方资源**：
    - [Gleam 官方网站](https://gleam.run/) - 获取语言介绍、安装指南和教程。
    - [Gleam 语言指南](https://gleam.run/book/tour/) - 全面的官方教程和参考。
    - [Gleam 标准库文档](https://hexdocs.pm/gleam_stdlib/) - 查阅所有内置模块和函数。
- **Advent of Code**：
    - [Advent of Code 官方网站](https://adventofcode.com/) - 参与每年的编程挑战。
- **BEAM 生态系统**：
    - [Hex.pm](https://hex.pm/) - BEAM 生态的软件包仓库，可查找 Erlang、Elixir 和 Gleam 包。
    - [Elixir 语言](https://elixir-lang.org/) 和 [Erlang 语言](https://www.erlang.org/) - 了解 Gleam 运行的平台。
- **社区与讨论**：
    - [Gleam Discord 服务器](https://discord.gg/Fm8Pwmy) - 活跃的社区讨论区。
    - [Gleam 论坛](https://gleam.run/news/) - 官方公告和讨论。

## 总结

通过作者使用 Gleam 完成 Advent of Code 2025 的实战之旅，我们得以深入窥见这门新兴函数式语言的真实面貌。Gleam 凭借其**简洁的语法、强大的类型推断、友好的编译器信息以及无缝的 BEAM 集成**，为开发者提供了一种既安全又愉悦的编程体验。它成功地将函数式编程的核心理念包装在一个易于接近的外壳中，特别适合用于构建高可靠性的后端服务、CLI工具或作为学习函数式思想的入门语言。

当然，作为一个年轻的语言，其**原生库生态仍在发展中**，这是潜在采用者需要权衡的因素。然而，其背后坚实的 BEAM 基石和活跃的社区为其未来增长提供了强大动力。

对于读者而言，无论你是想探索函数式编程的新可能，还是为下一个项目寻找一个可靠且高效的技术栈，Gleam 都值得你投入一些时间进行尝试。从解决几个 Advent of Code 谜题开始，亲身体验其“类型安全无噪音”的魅力，你可能会发现一种全新的、令人兴奋的构建软件的方式。