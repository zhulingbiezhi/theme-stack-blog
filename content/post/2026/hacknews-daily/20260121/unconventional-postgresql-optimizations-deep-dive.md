---
title: "非常规 PostgreSQL 优化策略：超越索引与查询重写的性能提升之道"
date: 2026-01-21
tags:
  - "postgresql"
  - "database-optimization"
  - "performance-tuning"
  - "sql"
  - "database-design"
  - "query-optimization"
  - "postgresql-tips"
  - "backend-development"
  - "data-modeling"
  - "database-performance"
categories:
  - "hacknews-daily"
draft: false
description: "本文深入解析了 Hakibenita 博客中提出的 PostgreSQL 非常规优化策略，涵盖从数据建模、索引设计到查询执行的多个层面。文章不仅总结了原文的七个核心优化技巧，还提供了深入的技术分析、实践场景和批判性思考，帮助数据库开发者和架构师在常规优化手段之外，发现新的性能提升途径。"
slug: "unconventional-postgresql-optimizations-deep-dive"
---

## 文章摘要

本文深入探讨了 Hakibenita 博客中提出的 PostgreSQL 非常规优化策略，这些策略超越了传统的索引优化和查询重写范畴。文章核心聚焦于七个关键优化技巧：使用 `UNION` 替代 `OR` 条件、利用部分索引减少索引大小、通过表达式索引优化函数调用、使用 `DISTINCT ON` 替代窗口函数、利用 `LATERAL JOIN` 优化相关子查询、通过物化视图预计算复杂查询，以及使用 `pg_stat_statements` 进行查询分析。这些策略的共同特点是它们往往被开发者忽视，但在特定场景下能带来显著的性能提升。对于中高级 PostgreSQL 用户和数据库架构师而言，本文提供了宝贵的实战经验和深度技术洞察，帮助在复杂的生产环境中解决性能瓶颈问题。

## 背景与问题

在当今数据驱动的应用开发中，PostgreSQL 作为最先进的开源关系数据库之一，承载着越来越多的关键业务数据。随着数据量的增长和查询复杂度的提升，数据库性能优化成为每个后端开发者和 DBA 必须面对的挑战。传统的优化手段——如添加合适的索引、重写低效查询、调整数据库配置参数——已经成为开发者的基本技能。然而，当这些常规手段用尽后，面对仍然存在的性能瓶颈，开发者往往感到束手无策。

这正是 Hakibenita 博客文章《Unconventional PostgreSQL Optimizations》所要解决的问题。文章作者基于多年的 PostgreSQL 实战经验，总结了一系列“非常规”的优化策略。这些策略之所以被称为“非常规”，并非因为它们复杂或难以理解，而是因为它们往往不在主流优化指南的讨论范围内，容易被开发者忽略。然而，正是这些被忽略的技巧，在特定场景下能够带来意想不到的性能提升。

文章的重要性在于它填补了 PostgreSQL 优化知识体系中的一个空白区域。大多数优化教程和文档都集中在索引策略、查询计划分析和配置调优上，但对于数据建模层面的优化、SQL 模式的选择以及 PostgreSQL 特有功能的深度利用，往往讨论不足。这篇文章的价值在于它从实际生产经验出发，提供了经过验证的优化模式，这些模式能够帮助开发者在面对复杂性能问题时，拥有更多的工具和思路。

从行业角度来看，随着微服务架构和云原生应用的普及，数据库层的性能优化变得更加关键。一个优化良好的查询可能意味着更少的资源消耗、更快的响应时间和更低的云服务成本。因此，掌握这些非常规优化策略，不仅能够提升应用性能，还能直接转化为成本节约和更好的用户体验。

## 核心内容解析

### 3.1 核心观点提取

**1. 使用 `UNION` 替代 `OR` 条件优化查询计划**
当查询中包含多个 `OR` 条件时，PostgreSQL 的查询优化器可能难以生成高效的执行计划。通过将单个包含 `OR` 的查询拆分为多个使用 `UNION` 的查询，可以允许优化器为每个分支选择最优的索引，然后合并结果。这种转换往往能显著提升查询性能，特别是当 `OR` 条件涉及不同列且选择性差异较大时。

**2. 利用部分索引减少索引大小和维护开销**
部分索引（Partial Index）只对表中满足特定条件的行创建索引，而不是对整个表创建索引。这对于具有高度倾斜数据分布的表特别有效，例如只对“活跃”状态的行创建索引。部分索引不仅能减少磁盘空间占用，还能降低索引维护的开销，同时保持对目标查询的高效支持。

**3. 通过表达式索引优化函数调用和计算列**
当查询条件中包含函数调用或表达式时，常规索引无法被利用。通过创建表达式索引，可以对函数或表达式的结果建立索引，从而允许基于这些计算结果的快速查找。这在处理规范化数据、大小写不敏感搜索或日期范围查询时特别有用。

**4. 使用 `DISTINCT ON` 替代窗口函数获取每组第一条记录**
在需要获取每个分组中第一条记录的常见场景中，开发者通常使用窗口函数（如 `ROW_NUMBER()`）。然而，PostgreSQL 提供了更简洁高效的 `DISTINCT ON` 语法，它专门为这种用例设计，通常能生成更简单的执行计划并减少不必要的排序操作。

**5. 利用 `LATERAL JOIN` 优化相关子查询**
相关子查询（Correlated Subquery）往往性能较差，因为外层查询的每一行都需要执行一次子查询。通过使用 `LATERAL JOIN`，可以将这种执行模式转换为更高效的连接操作，允许 PostgreSQL 优化器更好地规划查询执行顺序，并可能利用批处理优化。

**6. 通过物化视图预计算复杂查询结果**
对于计算成本高、访问频繁的复杂查询，物化视图（Materialized View）提供了一种有效的优化手段。物化视图将查询结果物理存储为表，可以像普通表一样建立索引，从而将复杂的运行时计算转换为简单的表扫描。虽然需要定期刷新，但在读多写少的场景中，这种权衡往往是值得的。

**7. 使用 `pg_stat_statements` 进行系统级查询分析**
`pg_stat_statements` 扩展提供了数据库级别的查询性能统计，能够识别出最耗时的查询、执行次数最多的查询以及平均执行时间最长的查询。这种系统级的视角帮助开发者发现那些在单个查询分析中容易被忽略，但累积影响巨大的性能问题。

### 3.2 技术深度分析

#### UNION 替代 OR 的技术原理

当 PostgreSQL 优化器处理包含 `OR` 条件的查询时，它面临一个挑战：如何为整个查询选择最优的执行计划。考虑以下查询：

```sql
-- 使用 OR 的查询
SELECT * FROM orders 
WHERE status = 'shipped' OR customer_id = 12345;
```

优化器可能难以同时为两个条件选择最优索引。如果为 `status` 和 `customer_id` 分别建立了索引，优化器可能选择其中一个索引进行扫描，然后对结果进行过滤，或者选择全表扫描。这两种方案都可能不是最优的。

通过将查询重写为 `UNION` 形式：

```sql
-- 使用 UNION 的优化版本
SELECT * FROM orders WHERE status = 'shipped'
UNION
SELECT * FROM orders WHERE customer_id = 12345;
```

现在优化器可以分别为两个查询选择最优的执行计划。第一个查询可能使用 `status` 索引，第二个查询可能使用 `customer_id` 索引。`UNION` 操作会自动去除重复行（如果需要保留重复行，可以使用 `UNION ALL`）。

这种优化的关键洞察在于：PostgreSQL 优化器在处理简单查询时往往比处理复杂查询时更聪明。通过将复杂查询分解为简单查询，我们让优化器能够在每个部分做出最优决策。

#### 部分索引的实际应用

部分索引的核心思想是“只为需要的数据建立索引”。考虑一个用户表，其中大部分用户处于“非活跃”状态，只有少数用户是“活跃”的：

```sql
-- 创建部分索引
CREATE INDEX idx_users_active ON users(email)
WHERE status = 'active';

-- 这个查询可以使用部分索引
SELECT * FROM users 
WHERE status = 'active' AND email LIKE 'john%@example.com';

-- 这个查询不能使用部分索引
SELECT * FROM users 
WHERE status = 'inactive' AND email LIKE 'john%@example.com';
```

部分索引的优势不仅在于减少索引大小，更重要的是减少索引维护开销。每次对表进行插入、更新或删除时，PostgreSQL 都需要更新相关的索引。通过只对部分行建立索引，我们减少了这些维护操作的开销。

然而，部分索引也有局限性：它们只在查询条件与索引条件匹配时才能被使用。这要求开发者对查询模式有深入的了解，并仔细设计索引条件。

#### LATERAL JOIN 的优化机制

`LATERAL JOIN` 是 PostgreSQL 中一个强大但常被忽视的功能。它允许子查询引用外层查询的列，类似于相关子查询，但以更高效的方式执行。考虑以下相关子查询：

```sql
-- 使用相关子查询
SELECT 
    u.id,
    u.name,
    (SELECT COUNT(*) FROM orders o WHERE o.user_id = u.id) as order_count
FROM users u;
```

这个查询为每个用户执行一次子查询，效率低下。使用 `LATERAL JOIN` 重写：

```sql
-- 使用 LATERAL JOIN 优化
SELECT 
    u.id,
    u.name,
    o.order_count
FROM users u
LEFT JOIN LATERAL (
    SELECT COUNT(*) as order_count 
    FROM orders 
    WHERE user_id = u.id
) o ON true;
```

`LATERAL JOIN` 的关键优势在于它允许优化器重新规划查询执行。在某些情况下，优化器可以将多个相关的 `LATERAL JOIN` 批处理，或者选择更高效的连接顺序。此外，`LATERAL JOIN` 的语法更加灵活，可以返回多个列，而不仅仅是标量值。

### 3.3 实践应用场景

这些非常规优化策略在实际开发中有广泛的应用场景：

**电商平台订单查询优化**：在大型电商平台中，订单查询往往包含复杂的过滤条件，如状态、时间范围、用户ID等组合。使用 `UNION` 替代 `OR` 可以显著提升这类查询的性能，特别是当不同过滤条件的选择性差异很大时。

**用户管理系统中的活跃用户查询**：在SaaS应用中，通常只有一小部分用户是活跃的。为活跃用户创建部分索引，可以大幅提升针对活跃用户的查询性能，同时减少索引维护开销。

**日志分析系统中的时间范围查询**：在日志分析场景中，经常需要按时间范围查询，并且可能需要对时间戳进行函数转换（如转换为特定时区）。为这些表达式创建索引，可以避免全表扫描。

**报表系统中的分组查询**：在生成报表时，经常需要获取每个分类的最新记录。使用 `DISTINCT ON` 替代窗口函数，可以使这类查询更加简洁高效。

**社交网络中的好友动态查询**：在社交网络中，查询用户好友的最新动态通常涉及复杂的相关子查询。使用 `LATERAL JOIN` 可以将这些查询转换为更高效的连接操作。

**数据仓库中的预聚合**：在数据仓库场景中，复杂的聚合查询可能非常耗时。使用物化视图预计算这些聚合结果，可以大幅提升查询响应时间，虽然需要权衡数据的新鲜度。

**生产环境性能监控**：在任何生产环境中，使用 `pg_stat_statements` 持续监控查询性能，可以帮助发现那些在开发环境中难以复现的性能问题，特别是那些执行频率高、单次执行时间短的查询。

## 深度分析与思考

### 4.1 文章价值与意义

Hakibenita 的这篇文章对 PostgreSQL 技术社区具有重要的价值。它不仅仅是一系列优化技巧的集合，更是对 PostgreSQL 优化思维模式的拓展。文章的价值体现在以下几个方面：

首先，文章填补了 PostgreSQL 优化知识体系中的一个重要空白。大多数优化指南都集中在“常规”优化手段上，如索引策略、查询重写基础、配置调优等。而这些“非常规”策略往往只在高级教程或特定场景的讨论中出现。文章将这些分散的知识点系统化地组织在一起，为开发者提供了一个全面的“高级优化工具箱”。

其次，文章强调了“理解数据库工作原理”的重要性，而不仅仅是“记住优化技巧”。每个优化策略都伴随着对 PostgreSQL 内部工作原理的解释，帮助读者理解“为什么”这些策略有效。这种深度理解使读者能够举一反三，在面对新的性能问题时，能够基于原理推导出合适的优化方案，而不是机械地应用记忆中的技巧。

第三，文章对行业实践产生了积极影响。随着 PostgreSQL 在企业和创业公司中的广泛应用，性能优化成为越来越重要的技能。这篇文章为开发者和 DBA 提供了实用的、经过生产验证的优化模式，有助于提升整个行业的数据库性能水平。

文章的创新点在于它从“非常规”的角度重新审视了 PostgreSQL 优化问题。作者没有重复那些已经被广泛讨论的优化技巧，而是挖掘了那些被忽视但有效的策略。这种视角的转换本身就是一个重要的贡献，它鼓励读者跳出常规思维，探索更多可能性。

### 4.2 对读者的实际应用价值

对于不同层次的读者，这篇文章提供了不同层面的价值：

**对于初级开发者**，文章提供了一个超越基础优化知识的学习路径。在掌握了索引、EXPLAIN 分析等基础知识后，这些非常规策略是进一步提升数据库技能的自然延伸。文章中的每个技巧都有具体的代码示例和应用场景，便于学习和实践。

**对于中级开发者**，文章提供了解决复杂性能问题的工具箱。当面对生产环境中的性能瓶颈时，这些策略可能成为突破常规优化手段限制的关键。特别是 `UNION` 替代 `OR` 和 `LATERAL JOIN` 优化相关子查询等技巧，在处理复杂业务逻辑时非常实用。

**对于高级开发者和架构师**，文章提供了优化思维模式的启发。更重要的是理解每个优化策略背后的原理和适用场景，从而能够在系统设计阶段就考虑性能优化，而不是在问题出现后才进行补救。例如，在设计数据模型时考虑部分索引的可能性，在编写复杂查询时考虑使用 `LATERAL JOIN` 等。

**对于 DBA 和运维人员**，文章中的 `pg_stat_statements` 使用技巧提供了系统级性能监控的方法论。通过持续监控和分析查询性能，可以 proactively 发现和解决性能问题，而不是被动地响应性能投诉。

从职业发展角度看，掌握这些高级优化技能使开发者在就业市场上更具竞争力。数据库性能优化是后端开发的核心技能之一，深入理解 PostgreSQL 的高级特性可以帮助开发者在技术面试和实际工作中脱颖而出。

### 4.3 可能的实践场景

基于文章内容，我建议读者在以下具体场景中实践这些优化策略：

**项目应用**：
1. 在现有的电商或社交应用中，识别包含多个 `OR` 条件的复杂查询，尝试使用 `UNION` 重写，并比较性能差异。
2. 在用户管理系统中，分析用户状态分布，为活跃用户创建部分索引，监控索引大小和查询性能的变化。
3. 在报表系统中，将使用窗口函数获取每组第一条记录的查询改为使用 `DISTINCT ON`，观察执行计划的变化。

**学习路径**：
1. 首先深入理解每个优化策略的原理，而不仅仅是记住语法。
2. 在测试环境中创建模拟数据集，实践每个优化技巧，使用 `EXPLAIN ANALYZE` 分析性能差异。
3. 阅读 PostgreSQL 官方文档中相关功能的详细说明，特别是关于查询优化器的部分。
4. 参与 PostgreSQL 相关社区讨论，了解其他开发者的优化经验和案例。

**工具推荐**：
1. **pgAdmin** 或 **DBeaver**：用于执行查询和分析执行计划。
2. **EXPLAIN ANALYZE**：PostgreSQL 内置的查询分析工具，是性能优化的核心工具。
3. **pg_stat_statements**：必须启用的扩展，用于系统级查询性能分析。
4. **PostgreSQL 官方文档**：最权威的学习资源，特别是“性能提示”和“索引”章节。
5. **pganalyze** 或 **pgHero**：第三方性能监控工具，提供更丰富的可视化分析。

### 4.4 个人观点与思考

在深入分析这篇文章后，我有以下几点补充思考：

首先，虽然文章中的优化策略非常有效，但需要强调的是，它们并不是“银弹”。每个优化都有其适用场景和局限性。例如，使用 `UNION` 替代 `OR` 时，需要注意 `UNION` 会去除重复行（除非使用 `UNION ALL`），这可能改变查询的语义。此外，过度使用 `UNION` 可能导致查询变得复杂难懂，增加维护成本。

其次，我认为文章可以更加强调“测量驱动优化”的重要性。在应用任何优化策略之前，必须使用 `EXPLAIN ANALYZE` 测量当前性能，并在优化后再次测量，确保优化确实有效。性能优化中最危险的假设是“这个改变应该能提升性能”，而不进行实际测量。

第三，关于物化视图的使用，文章提到了需要定期刷新的问题。在实际应用中，物化视图的刷新策略需要仔细设计。对于实时性要求高的场景，可能需要使用触发器或逻辑复制来保持物化视图的更新；对于可以接受一定延迟的场景，定时刷新可能是更简单有效的方案。

最后，我想补充一个文章未提及但非常重要的观点：优化应该从数据模型设计开始。很多性能问题的根源在于不合理的数据模型设计。例如，过度规范化可能导致需要大量连接操作，而过度反规范化可能导致数据冗余和更新异常。在应用这些查询层优化之前，应该首先评估数据模型是否合理。

从未来发展的角度看，随着 PostgreSQL 版本的更新，一些优化策略可能会变得不那么必要。例如，PostgreSQL 的优化器在不断改进，未来可能会更好地处理包含 `OR` 条件的查询。因此，保持对 PostgreSQL 新版本的关注，了解优化器的改进，也是持续优化的重要部分。

## 技术栈/工具清单

本文讨论的优化策略主要围绕 PostgreSQL 数据库系统，涉及以下核心技术、工具和扩展：

**核心数据库**：
- PostgreSQL 9.5+（部分功能如 `LATERAL JOIN` 在更早版本也可用，但建议使用较新版本以获得最佳优化器支持）

**关键 PostgreSQL 功能**：
- `UNION` / `UNION ALL` 查询操作符
- 部分索引（Partial Indexes）
- 表达式索引（Expression Indexes）
- `DISTINCT ON` 子句
- `LATERAL JOIN`
- 物化视图（Materialized Views）
- 公共表表达式（CTEs，虽然文章未重点讨论，但与优化相关）

**性能分析工具**：
- `EXPLAIN` 和 `EXPLAIN ANALYZE`：内置查询计划分析工具
- `pg_stat_statements` 扩展：查询性能统计收集
- `auto_explain` 扩展：自动记录慢查询的执行计划

**监控和管理工具**：
- **pgAdmin**：流行的 PostgreSQL 图形化管理工具
- **psql**：PostgreSQL 命令行工具，适合高级用户
- **PostgreSQL 日志**：通过配置 `log_min_duration_statement` 记录慢查询

**推荐的学习资源**：
1. PostgreSQL 官方文档：https://www.postgresql.org/docs/
2. 《PostgreSQL 修炼之道：从小工到