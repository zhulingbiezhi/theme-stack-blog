---
title: "在 C 语言中编写游戏：一场关于性能、控制与编程本质的深度探索"
date: 2026-02-08
tags:
  - "C语言"
  - "游戏开发"
  - "性能优化"
  - "编程范式"
  - "软件工程"
  - "内存管理"
  - "跨平台开发"
  - "SDL"
  - "复古编程"
  - "系统编程"
categories:
  - "hacknews-daily"
draft: false
description: "本文深入探讨了在 2016 年乃至今天，为何仍有开发者选择使用纯粹的 C 语言进行游戏开发。文章超越了简单的技术选型讨论，从性能控制、心智模型、工程哲学等角度，分析了 C 语言在游戏开发领域的独特价值、面临的挑战以及它所带来的深刻编程启示。"
slug: "writing-games-in-c-language-deep-dive"
---

## 文章摘要

本文基于 Jonathan Whiting 的博文《I write games in C (yes, C)》，深入剖析了在现代游戏开发被 C++、C# 及各类游戏引擎主导的背景下，坚持使用纯 C 语言进行开发的深层原因与实践价值。文章不仅总结了原作者的核心论点——C 语言带来的极致性能控制、简洁的心智模型和跨平台便利性——更从软件工程哲学、技术演进脉络和开发者成长角度进行了深度扩展。我们探讨了手动内存管理、数据导向设计、最小依赖原则在游戏开发中的具体应用，分析了 C 语言项目在现代工具链下的可行性，并最终指出，这种实践的核心价值在于对计算机系统本质的深刻理解与掌控，这对于任何层级的开发者都是一种宝贵的思维训练。

## 背景与问题

在当今的游戏工业界，Unity（C#）、Unreal Engine（C++）以及 Godot（GDScript/C#）等成熟引擎构成了绝对的主流。它们提供了丰富的功能、庞大的资产商店和相对较低的上手门槛，使得独立开发者和小团队也能创造出视觉效果惊人的作品。在这种环境下，“使用 C 语言从头开始写游戏”听起来像是一种复古的行为艺术，甚至是一种不必要的“硬核”自虐。

然而，这种观点忽略了一个关键维度：**技术选型的目的不仅仅是产出最终产品，更是塑造开发者的思维方式和工程能力**。Jonathan Whiting 的文章正是在这样的语境下提出了一个反直觉的命题：选择 C 语言，并非出于对现代工具的排斥，而是为了追求一种**极致的清晰度、控制力和可移植性**。

从技术背景看，C 语言诞生于 1972 年，其设计哲学是“信任程序员”，提供接近硬件的底层操作能力，同时保持足够的抽象以避免汇编语言的繁琐。正是这种特性，使得它成为操作系统、嵌入式系统和性能关键型应用的基石。尽管 C++ 在游戏开发中因其面向对象特性而备受青睐，但它也引入了复杂性（如多重继承、异常处理、RTTI），这些特性有时会与游戏开发所要求的确定性和高性能产生冲突。

因此，本文要探讨的核心问题是：在一个高级语言和框架唾手可得的时代，回归 C 语言进行游戏开发，究竟能带来哪些独特的、不可替代的价值？这不仅仅是关于“如何用 C 写游戏”的技术问题，更是关于“我们如何理解计算机、如何管理复杂性、如何定义简洁有效的软件”的哲学问题。

## 核心内容解析

### 3.1 核心观点提取

**1. 性能的终极掌控**
C 语言将内存和计算资源的控制权完全交还给程序员。没有垃圾回收（GC）的不可预测停顿，没有虚拟函数调用的间接开销，没有复杂运行时环境带来的额外负担。对于游戏这种需要稳定帧率（如 60 FPS，即每帧仅 16.6 毫秒）的实时交互应用，这种确定性的性能表现至关重要。程序员可以精确地知道每一字节内存的分配与释放时机，优化缓存命中率，实现数据导向设计（Data-Oriented Design），从而榨干硬件的最后一点性能。

**2. 简洁与透明的心智模型**
C 语言的语法和语义相对简单，标准库小巧。这意味着整个程序的“状态空间”对开发者是透明的。没有隐藏的魔法（Magic），没有复杂的继承层次和设计模式带来的间接层。当程序出现 bug 时，从源代码到机器指令的映射路径更短、更直接，极大地简化了调试和理解程序全貌的过程。这种简洁性降低了长期维护的认知负荷。

**3. 无与伦比的跨平台能力**
C 语言编译器几乎存在于所有已知的计算平台上。结合像 SDL（Simple DirectMedia Layer）这样用 C 编写的跨平台媒体库，开发者可以用一套代码轻松编译并运行在 Windows、macOS、Linux、甚至更小众的平台上。这种可移植性源于 C 语言作为“可移植的汇编语言”的定位，以及其极小的运行时依赖。

**4. 依赖最小化与部署简便**
一个用纯 C 和 SDL 编写的游戏，其最终二进制文件通常只依赖于目标系统的基础 C 运行时库（如 `libc`）和 SDL 库。这使得分发变得极其简单，避免了现代游戏引擎动辄数百 MB 的运行时包或复杂的依赖安装过程。对于小型游戏或面向特定平台（如复古硬件）的项目，这是一个巨大优势。

**5. 对计算机系统的深刻教育**
使用 C 语言开发游戏是一个绝佳的学习过程。它迫使开发者直面内存管理、指针运算、硬件资源限制等底层问题。这种经历能培养出对计算机系统工作原理的深刻直觉，这种直觉在使用高级语言时同样宝贵，能帮助开发者写出更高效、更健壮的代码。

### 3.2 技术深度分析

**技术原理与实现范式**
用 C 语言进行游戏开发，其核心范式通常围绕一个主循环（Game Loop）展开。这个循环顺序处理输入（Input）、更新游戏状态（Update）和渲染（Render）。由于没有面向对象的语法糖，游戏状态通常被组织在全局结构体（`struct`）或传递给函数的上下文结构中。

```c
typedef struct {
    SDL_Window* window;
    SDL_Renderer* renderer;
    Entity entities[MAX_ENTITIES];
    int running;
} GameState;

void process_input(GameState* state) {
    SDL_Event event;
    while (SDL_PollEvent(&event)) {
        if (event.type == SDL_QUIT) state->running = 0;
        // ... 处理其他输入
    }
}

void update(GameState* state, float delta_time) {
    // 更新所有实体位置、状态等
    for (int i = 0; i < MAX_ENTITIES; i++) {
        update_entity(&state->entities[i], delta_time);
    }
}

void render(GameState* state) {
    SDL_RenderClear(state->renderer);
    // 渲染所有实体
    for (int i = 0; i < MAX_ENTITIES; i++) {
        render_entity(state->renderer, &state->entities[i]);
    }
    SDL_RenderPresent(state->renderer);
}

int main() {
    GameState state = {0};
    init_game(&state);

    Uint32 last_time = SDL_GetTicks();
    while (state.running) {
        Uint32 current_time = SDL_GetTicks();
        float delta_time = (current_time - last_time) / 1000.0f;
        last_time = current_time;

        process_input(&state);
        update(&state, delta_time);
        render(&state);

        // 简单的帧率控制
        SDL_Delay(1);
    }

    cleanup_game(&state);
    return 0;
}
```

**内存管理策略**
放弃垃圾回收意味着手动管理内存。在游戏开发中，这通常通过**对象池（Object Pool）** 和**竞技场分配器（Arena Allocator）** 等模式来实现，以避免频繁的 `malloc/free` 调用带来的性能抖动和内存碎片。
- **对象池**：在游戏初始化时，一次性分配好所有可能用到的实体（如子弹、敌人）数组。使用时从池中“激活”一个，用完后“禁用”并归还，避免动态分配。
- **竞技场分配器**：为特定生命周期（如一帧或一个关卡）的数据分配一大块内存，在该生命周期内从此内存块中线性分配。生命周期结束时，一次性释放整个内存块，效率极高且无碎片。

**数据导向设计（DOD）**
这是 C 语言游戏开发中的高级优化技巧。与面向对象设计（OOD）将数据和方法封装在对象内不同，DOD 主张将数据（结构体数组）与操作（函数）分离，以优化 CPU 缓存利用率。
例如，更新 10000 个实体的位置，OOD 可能是 `for each entity: entity.update()`，这会导致 CPU 在内存中跳跃访问每个对象的不同部分（位置、生命值、纹理等）。而 DOD 会这样做：
```c
// 数据存储为数组
Vec2 positions[MAX_ENTITIES];
float health[MAX_ENTITIES];
// 更新操作
for (int i = 0; i < active_count; i++) {
    positions[i].x += velocities[i].x * delta_time;
    positions[i].y += velocities[i].y * delta_time;
}
```
所有位置数据在内存中是连续的，CPU 预取和缓存命中率大幅提升，在现代 CPU 上可能带来数量级的性能差异。

### 3.3 实践应用场景

**适用场景**
1.  **性能至上的小型游戏**：如复古风格的 2D 动作游戏、益智游戏，其中每一毫秒的性能都至关重要。
2.  **嵌入式或资源受限环境**：在树莓派、复古游戏机（通过自制）或其他内存和算力有限的设备上运行的游戏。
3.  **游戏原型与核心机制验证**：当你需要剥离所有引擎的复杂性，快速验证一个游戏的核心玩法循环时，一个简单的 C 程序可能比启动一个完整的游戏引擎更快。
4.  **教育目的**：作为计算机科学或游戏编程课程的一部分，帮助学生理解图形、输入、物理模拟等的基础原理。
5.  **特定平台工具**：开发需要深度集成到操作系统或特定硬件中的游戏相关工具。

**实际案例与最佳实践**
- **案例**：许多经典的“demoscene”作品（在极小的文件尺寸内展示惊人视听效果的实时程序）都是用 C 或汇编编写的，以追求极限性能。
- **最佳实践**：
    1.  **使用 SDL 作为跨平台抽象层**：处理窗口、输入、声音和基本 2D 渲染。
    2.  **采用实体组件系统（ECS）的简化版**：即使不用完整的 ECS 框架，也可以用结构体数组来模拟组件，用函数来操作系统。
    3.  **将平台相关代码严格隔离**：将文件 I/O、线程等可能因平台而异的代码封装在单独的模块中，便于移植。
    4.  **拥抱现代 C 标准（如 C11/C17）**：利用 `stdint.h` 中的明确类型（`uint32_t`）、静态断言（`static_assert`）等特性提高代码安全性和可读性。
    5.  **利用现代工具链**：即使使用 C 语言，也可以享受 Clang/LLVM 优秀的错误提示、AddressSanitizer 等内存检测工具，以及 Visual Studio Code 等现代编辑器的支持。

## 深度分析与思考

### 4.1 文章价值与意义

Jonathan Whiting 的文章发表于 2016 年，正值 Unity 和 Unreal Engine 的普及浪潮中。它的价值在于提供了一个**冷静的、逆向的思考锚点**。在技术社区热衷于讨论最新的引擎特性、渲染管线或脚本语言时，这篇文章提醒我们回归基础：计算机程序最终是如何在硬件上执行的。

它对技术社区的贡献在于：
- **挑战了“技术进步等于抽象层级提高”的线性叙事**。它表明，有时“向下”走，接近金属，反而能获得更优的解决方案和更深刻的理解。
- **强调了“简单性”作为一种工程美德的重要性**。C 语言的简单性（非易用性）带来了可预测性、可维护性和可移植性，这些在长期项目中可能比短期的开发速度更重要。
- **为游戏开发教育提供了一个纯净的起点**。从 C 和 SDL 开始学习游戏编程，可以避免被引擎编辑器、资产管道等“黑盒”所迷惑，直接触及游戏作为“实时交互模拟程序”的本质。

文章的亮点在于，它没有陷入“C 语言优于一切”的极端论调，而是客观地陈述了其优缺点，并将其定位为一种**合理且强大的技术选择**，尤其适合特定类型的项目和特定追求的开发者。

### 4.2 对读者的实际应用价值

对于不同背景的读者，这篇文章的价值维度不同：

- **对于使用高级语言/引擎的开发者**：这是一次“精神俯卧撑”。理解 C 语言游戏开发的约束和解决方案，能让你在使用 Unity 或 Unreal 时，更清楚引擎在背后为你做了什么，从而能更好地诊断性能问题、理解内存分配模式，甚至为引擎编写更高效的原生插件。你会开始思考“这个 GameObject 在内存中是如何布局的？”这类问题。
- **对于系统程序员或嵌入式开发者**：这篇文章展示了如何将你们的技能应用到游戏开发这个充满趣味的领域，拓宽了职业可能性。
- **对于学生和新手**：这提供了一条避开复杂引擎、直击核心的学习路径。虽然起步可能更陡峭，但建立的基础知识体系将异常牢固。你学到的不是“如何在 Unity 中点击按钮”，而是“计算机如何绘制一帧图像”。
- **对于技术负责人或架构师**：这篇文章是关于技术选型的案例研究。它展示了如何根据项目目标（性能、可移植性、团队技能、维护周期）而非行业潮流来选择技术栈。

### 4.3 可能的实践场景

- **个人挑战项目**：设定一个目标，如“用 C 和 SDL 在三个月内制作一个完整的《打砖块》克隆版”。这将全面锻炼你的输入处理、碰撞检测、渲染和游戏状态管理能力。
- **性能优化实验场**：如果你对某个算法（如 A* 寻路、流体模拟）的性能有疑问，用 C 语言实现一个最纯净的版本作为基准，与高级语言实现进行对比，可以排除运行时环境的干扰，得到最本质的性能洞察。
- **复古硬件移植**：购买一块复古的开发板（如基于 68000 处理器的），尝试将你的 C 游戏移植上去。这将把你对可移植性和资源管理的理解推向极致。
- **参与开源项目**：有许多优秀的、用 C 编写的开源游戏和框架，如 `Dungeon Crawl: Stone Soup`、`Cataclysm: Dark Days Ahead`，或者更现代的 `raylib` 游戏库。阅读和贡献代码是绝佳的学习方式。

### 4.4 个人观点与思考

Whiting 的文章极具启发性，但我们也需要一些批判性思考。纯粹的 C 语言开发在 **2023年及以后** 面临一些新的挑战：

1.  **生态系统的差距**：现代游戏开发不仅仅是图形和逻辑。需要强大的工具链支持 3D 模型导入、动画编辑、粒子特效编辑、关卡设计等。用 C 语言构建或集成这些工具需要巨大的额外投入。像 `raylib` 这样的库正在努力弥补这一差距，但与传统引擎的成熟度仍有距离。
2.  **安全性与现代实践**：C 语言的内存安全问题（缓冲区溢出、Use-After-Free）是永恒的挑战。虽然通过严谨的纪律、静态分析工具（如 Clang Static Analyzer, Coverity）和运行时检测（如 ASan, MSan）可以极大缓解，但这增加了心智负担和开发成本。
3.  **团队协作的挑战**：在大型团队中，强制所有人遵循严格的手动内存管理和无抽象的设计模式，可能比使用一种更“安全”或更“富有表达力”的语言带来更高的沟通和培训成本。

**未来展望**：我认为，C 语言在游戏开发中的角色不会消失，但可能会进一步分化。一方面，它将继续是**高性能游戏引擎核心层**（如 Unity 的 IL2CPP 后端、Unreal 的核心运行时）和**主机游戏关键模块**的首选。另一方面，在独立开发领域，像 `Zig`、`Jai` 或 `Odin` 这样旨在提供类似 C 的控制力和性能，但拥有更现代语法和安全性保证的新兴语言，可能会吸引那些欣赏 C 哲学但希望更好工具支持的开发者。

无论如何，**“用 C 写游戏”的精神内核——对底层系统的掌控、对性能的追求、对简洁设计的信仰——将永远是高质量软件工程的重要组成部分**。无论你最终使用哪种语言，拥有这种思维模式都将使你成为一名更出色的开发者。

## 技术栈/工具清单

基于原文精神及现代实践，一个典型的 C 语言游戏开发技术栈可能包括：

- **核心语言**：ANSI C (C99) 或 ISO C (C11/C17)。推荐使用较新标准以获得更好的类型安全和特性。
- **编译器**：
    - `gcc` (GNU Compiler Collection)：Linux 上的标准，跨平台支持好。
    - `clang`/`LLVM`：提供卓越的错误和警告信息，以及强大的静态分析工具。
    - `MSVC` (Microsoft Visual C++)：在 Windows 上进行开发的最佳选择，集成性好。
- **核心库**：
    - **SDL2 (Simple DirectMedia Layer)**：**事实标准**。处理窗口、OpenGL/DirectX 上下文创建、输入（键盘、鼠标、手柄）、声音、线程等。是跨平台开发的基石。
    - **raylib**：一个更新的、以“简单易学”为设计理念的游戏库。提供了更高层次的抽象（如直接绘制图形、处理摄像机），同时保持纯 C 实现和极小的依赖。非常适合初学者和快速原型开发。
- **图形 API**（可选，SDL/raylib 已封装）：
    - **OpenGL**：用于 2D/3D 渲染。可通过 SDL 创建上下文。
    - **Vulkan**：用于追求极致性能和控制的现代低级图形 API。学习曲线陡峭。
- **辅助工具**：
    - **构建系统**：`CMake`（推荐，跨平台）、`Makefile`（传统）、或 `xmake`（新兴）。
    - **调试器**：`GDB` (Linux/macOS)、`LLDB` (macOS)、Visual Studio Debugger (Windows)。
    - **内存检测工具**：AddressSanitizer (ASan)、UndefinedBehaviorSanitizer (UBSan)。
    - **性能分析器**：`perf` (Linux)、Instruments (macOS)、Very Sleepy (Windows)、`tracy`（优秀的跨平台帧分析器）。
- **IDE/编辑器**：
